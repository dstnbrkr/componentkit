<p>Create components using the <code>newWithView:size:</code> class method:</p>

<p><code>objc++
+ (instancetype)newWithView:(CKComponentViewConfiguration)view
                       size:(CKComponentSize)size;
</code></p>

<p>It’s important to note that you don’t pass a <code>UIView</code> directly, but a <code>CKComponentViewConfiguration</code>. What’s that?</p>

<p><code>objc++
struct CKComponentViewConfiguration {
  CKComponentViewClass viewClass;
  std::unordered_map&lt;CKComponentViewAttribute, id&gt; attributes;
};
</code></p>

<p>The first field is a view class. Ignore <code>CKComponentViewClass</code> for now—in most cases you just pass a class like <code>[UIImageView class]</code> or <code>[UIButton class]</code>.</p>

<p>The second field holds a map of attributes to values: font, color, background image, and so forth. Again, ignore <code>CKComponentViewAttribute</code> for now; you can usually use a <code>SEL</code> as the attribute. If you notice, the values in the map are of type <code>id</code>, so if you want to pass in primitive types like <code>BOOL</code>, you have to wrap them into a <code>NSNumber</code> using <code>@(value)</code> and the infrastructure will unwrap them.</p>

<p>Let’s put one together:</p>

<p><code>objc++
[CKComponent newWithView:{
  [UIImageView class],
  {
    {@selector(setImage:), image},
    {@selector(setContentMode:), @(UIViewContentModeCenter)} // Wrapping into an NSNumber
  }
}];
</code></p>

<p>That’s all there is to it. The infrastructure does this for us:</p>

<ul>
  <li>Automatically creates or reuses a <code>UIImageView</code> when the component is mounted</li>
  <li>Automatically calls <code>setImage:</code> and <code>setContentMode:</code> with the given values</li>
  <li>Skips calling <code>setImage:</code> or <code>setContentMode:</code> if the value is unchanged between two updates — the most common case when updating a tree.</li>
</ul>

<h1 id="viewless-components">Viewless Components</h1>

<p>Often there are logical components that don’t need a corresponding view in the view hierarchy. <code>CKUFIComponent</code> doesn’t really need a view; it only needs to position various subviews inside a designated area. Just pass <code>{}</code> for the view configuration and no view is created:</p>

<p><code>objc++
[CKComponent newWithView:{} size:{}]
</code></p>

<p>(You can also just use <code>+new</code> directly, which uses this as the default.)</p>

<h1 id="advanced-views">Advanced Views</h1>

<p>This is sufficient for most cases, but there is considerably more power when you need it. See <a href="docs/advanced-views">advanced-views</a> if you want to learn more.</p>
