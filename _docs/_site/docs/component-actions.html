<p>Often child components must communicate back to their parents. For example, a button component may need to signal that it has been tapped. Component actions provide a way to do this.</p>

<h3 id="what-are-component-actions">What are Component Actions?</h3>

<p><code>CKComponentAction</code> is just an alias for <code>SEL</code> — basically, a method name.</p>

<p>The <code>CKComponentActionSend</code> function takes an action, a sender, and an optional opaque context object. It follows the <a href="docs/controls-and-the-responder-chain">component responder chain</a> until it finds a component (or component controller) that responds to the given selector, then sends a message with the sender and context as parameters.</p>

<p>(The only reason for the alias is to document that you expect the <code>SEL</code> to be called via <code>CKComponentActionSend</code>.)</p>

<h3 id="using-component-actions">Using Component Actions</h3>

<p>Here’s an example of how to handle a component action. (The API for <code>CKButtonComponent</code> has been simplified for this example.)</p>

<p>```objc++
@implementation CKSampleComponent
+ (instancetype)new
{
  return [super newWithComponent:
          [CKButtonComponent
           newWithAction:@selector(someAction:)]];
}</p>

<ul>
  <li>(void)someAction:(CKButtonComponent *)sender
{
// Do something
}
@end
```</li>
</ul>

<h3 id="why-not-blocks">Why not blocks?</h3>

<p>Blocks might seem like a more natural way to specify callbacks. Unfortunately it’s far too easy to introduce retain cycles when using blocks: components hold strong references to their child components, and the child might hold a block with a strong reference back to the parent.</p>
