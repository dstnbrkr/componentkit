<p>Back in <a href="docs/views">Views</a> we glossed over <code>CKComponentViewClass</code> and <code>CKComponentViewAttribute</code>. But there’s a surprising amount of power hiding here!</p>

<p><code>CKComponentViewClass</code> describes how to create a <code>UIView</code>. Usually you pass an Objective-C class like <code>[UIImageView class]</code>, and the infrastructure will automatically create a view by invoking the designated initializer <code>-initWithFrame:</code>.</p>

<p>But of course, not all views can be created with <code>-initWithFrame:</code>. For these cases, there’s an advanced constructor that takes a block:</p>

<p><code>objc++
CKComponentViewClass(std::string identifier, UIView *(^factory)(void));
</code></p>

<p>This allows you to use almost any view with Components. </p>

<div class="note-important">
  <p> 
    However, the factory takes no arguments; you can't pass any properties from a particular component to a view's `-init`, since views must be arbitrarily recycled between components. If your view takes properties in `-init`, one possible pattern is to create a wrapping view with setter methods that tear down and re-create the problematic view as a subview.
  </p>
</div>

<p><code>CKComponentViewAttribute</code> has similar underpinnings. Usually you pass a <code>SEL</code>, but under the hood they’re basically just arbitrary blocks paired with a unique identifier:</p>

<p><code>objc++
struct CKComponentViewAttribute {
  std::string identifier;
  void (^applicator)(id view, id value);
  void (^unapplicator)(id view, id value);
  void (^updater)(id view, id oldValue, id newValue);
};
</code></p>

<p>This allows you to express arbitrarily complex operations on the view, like “call this method with these N arguments”. The only restriction is that you must box up the inputs to the block in a single <code>id</code> so the infrastructure can determine if it has changed across recyclings.</p>

<div class="note">
  <p> 
    How does passing a `Class` or `SEL` work for these classes? They each have a single-argument constructor that takes a `Class`/`SEL` and creates an object that creates the right thing. C++ implicitly calls this constructor when you pass a `Class`/`SEL`.
  </p>
</div>
