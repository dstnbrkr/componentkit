<h2 id="this-means-we-cant-use-uikit-directly">This means we can’t use UIKit directly.</h2>

<p>True. If we want to do asynchronous, off-main-thread sizing, we can’t use UIKit directly.</p>

<p>Beyond performance, though, we believe the declarative style of React and Components is a superior programming model.</p>

<p>It’s easy to create a component that simply wraps a <code>UIView</code>. (See <a href="docs/views">views</a> for an example.)</p>

<h2 id="new-developers-will-face-a-learning-curve">New developers will face a learning curve.</h2>

<p>We now use React JS extensively on www which also has a learning curve. Doing view layout declaratively has so many advantages that the benefits win out.</p>

<p>This system also places restrictions on developers which make layout more reliable. For example, a <code>UIView</code>’s <code>sizeThatFits:</code> may think it should be rendered at 200x100, but then someone adds a new separator view to <code>layoutSubviews</code> and forgets to update <code>sizeThatFits:</code>, so now there’s a weird overlapping content bug. </p>

<p>Components make this kind of bug impossible. It’s like bumper bowling for view layout!</p>

<h2 id="well-have-to-reimplement-each-view-as-a-component">We’ll have to reimplement each view as a component.</h2>

<p>Not true; you don’t need to add a new subclass of <code>CKComponent</code> to use a given <code>UIView</code>. For example:</p>

<p><code>objc++
[CKComponent newWithView:{[UIButton class], }]
</code></p>

<p>However, there is <em>e.g.</em> <code>CKButtonComponent</code>, <code>CKImageComponent</code> and so forth, which provide syntactic sugar for common attributes (titles for buttons, targets for controls, and so forth). These are very thin wrappers that merely transform their inputs.</p>

<p>There is no reimplementation of tap handling and the responder chain (as there was in legacy feed) and no reimplementation of display and layout semantics (as there is in <code>ASDisplayNode</code>).</p>

<h2 id="how-is-this-different-from-asdisplaynode">How is this different from <code>ASDisplayNode</code>?</h2>

<ul>
  <li>Nodes are not immutable; they expose mutative methods like <code>addSubnode:</code> and <code>removeSubnode:</code>.</li>
  <li>Nodes are not declarative.</li>
  <li>When modifying a node, you mutate the existing node and it updates its corresponding view synchronously; components re-render a completely new tree from the root and update the existing hierarchy.</li>
  <li>You cannot currently recycle a view hierarchy for use between two different nodes.</li>
</ul>

<h2 id="this-violates-mvc">This violates MVC.</h2>

<p>Components may be the target of actions and update their state in response to those actions.</p>

<p>This objection is touched on briefly in the example in <a href="docs/state">state</a>. I believe that because components are immutable and declarative, there is no danger to having them handle <em>limited</em> types of user actions.</p>

<p>MVC exists to tame the beast of mutable state. If your view is updating its state willy-nilly and the controller doesn’t know about it, you’re soon going to end up with a mess.</p>

<p>Components make updating the view without the controller knowing about it impossible. So when components can intercept a user tap and announce “my state has changed in this way, please re-render me,” they’re not violating MVC; they’re just encapsulating that state change logic. The controller is still the component that is re-rendering the view.</p>
