<p>Avoid excessive branching in component code. Components are best read top-down and any branching introduces complications in understanding the layout. If you find yourself branching too much, consider separating your component into smaller components and composing them. </p>

<p>TODO: Examples of code smell</p>

<h1 id="branching-strategy-for-ipad">Branching Strategy for iPad</h1>

<p>There are generally two situations for iPad: either the component is going to render similarly on both iPhone or iPad, or render completely differently.</p>

<h2 id="similar">Similar</h2>

<p>TODO: Add example</p>

<p>In this case you should generally share the overall layout and introduce <code>[CKDevice isPad]</code> checks in the 1-2 places that it is needed. Generally these end up being inline checks using a ternary operator. For example</p>

<p><code>objc++
[CKInsetComponent
 newWithInsets:[CKDevice isPad] ? UIEdgeInsetsMake(0, 0, 8.0, 9.0) : UIEdgeInsetsMake(0, 0, 3.0, 4.0)
 component: ...]
</code></p>

<h2 id="different">Different</h2>

<p>TODO: Add example</p>

<p>If you’re using <code>[CKDevice isPad]</code> checks in more than 2-3 places, it’s preferable to completely separate the iPhone and iPad implementations of the component structure and branch <strong>only once</strong>. Avoid branching on <code>[CKDevice isPad]</code> checks in helper functions.</p>

<p><code>objc++
if ([CKDevice isPad]) {
  // iPad rendering
} else {
  // iPhone rendering
}
</code></p>

<h1 id="reasoning">Reasoning</h1>

<p>Code tends to accumulate a lot of these device based checks over time. Having a lot of iPad checks in various places makes the code paths difficult to reason about between iPhone and iPad. There’s much more value in being able to read code top down for the iPhone case and separately for the iPad case. Legacy attachment controllers (such as <code>CKLinkShareAttachmentController</code>) are proof of the bad situation that results when we use too many device based checks.</p>
